{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils/utils\";\n\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\" + baseComponentName;\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\n\n\nvar ObjectToBeRetainedByReact =\n/** @class */\nfunction () {\n  function ObjectToBeRetainedByReact() {}\n\n  return ObjectToBeRetainedByReact;\n}();\n\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n\n  var _a = __read(React.useState(new ObjectToBeRetainedByReact()), 1),\n      objectRetainedByReact = _a[0];\n\n  var forceUpdate = useForceUpdate(); // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n\n  var reactionTrackingRef = React.useRef(null);\n\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData_1.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        trackingData_1.changedBeforeMount = true;\n      }\n    });\n    var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n  }\n\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true; // Got a change before first mount, force an update\n\n      if (reactionTrackingRef.current.changedBeforeMount) {\n        reactionTrackingRef.current.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          forceUpdate();\n        }),\n        mounted: true,\n        changedBeforeMount: false,\n        cleanAt: Infinity\n      };\n      forceUpdate();\n    }\n\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []); // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n\n  var rendering;\n  var exception;\n  reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"mappings":"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","names":["Reaction","React","printDebugValue","addReactionToTrack","recordReactionAsCommitted","isUsingStaticRendering","useForceUpdate","observerComponentNameFor","baseComponentName","useObserver","fn","useState","ObjectToBeRetainedByReact","objectRetainedByReact","forceUpdate","reactionTrackingRef","useRef","current","newReaction","trackingData_1","mounted","changedBeforeMount","reaction","useDebugValue","useEffect","cleanAt","Infinity","dispose","rendering","exception","track","e"],"sources":["D:\\test\\SPP\\SPP\\app\\client\\node_modules\\mobx-react-lite\\src\\useObserver.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\nimport React from \"react\"\n\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport {\n    addReactionToTrack,\n    IReactionTracking,\n    recordReactionAsCommitted\n} from \"./utils/reactionCleanupTracking\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useForceUpdate } from \"./utils/utils\"\n\nfunction observerComponentNameFor(baseComponentName: string) {\n    return `observer${baseComponentName}`\n}\n\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nclass ObjectToBeRetainedByReact {}\n\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return fn()\n    }\n\n    const [objectRetainedByReact] = React.useState(new ObjectToBeRetainedByReact())\n\n    const forceUpdate = useForceUpdate()\n\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    const reactionTrackingRef = React.useRef<IReactionTracking | null>(null)\n\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate()\n            } else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData.changedBeforeMount = true\n            }\n        })\n\n        const trackingData = addReactionToTrack(\n            reactionTrackingRef,\n            newReaction,\n            objectRetainedByReact\n        )\n    }\n\n    const { reaction } = reactionTrackingRef.current!\n    React.useDebugValue(reaction, printDebugValue)\n\n    React.useEffect(() => {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef)\n\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false\n                forceUpdate()\n            }\n        } else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\n                    // We've definitely already been mounted at this point\n                    forceUpdate()\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            }\n            forceUpdate()\n        }\n\n        return () => {\n            reactionTrackingRef.current!.reaction.dispose()\n            reactionTrackingRef.current = null\n        }\n    }, [])\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let rendering!: T\n    let exception\n    reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return rendering\n}\n"]},"metadata":{},"sourceType":"module"}